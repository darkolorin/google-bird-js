<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simple Flappy Bird</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            background-color: #71c5cf;
            touch-action: none;
        }
        
        canvas {
            display: block;
            background-color: #71c5cf;
            touch-action: none;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        // Initialize Telegram Mini App
        const tgApp = window.Telegram?.WebApp;
        if (tgApp) {
            tgApp.expand();
            tgApp.ready();
        }

        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        let canvasWidth = 360;
        let canvasHeight = 640;
        
        // Resize to fit screen (maintaining aspect ratio)
        function resizeCanvas() {
            const windowRatio = window.innerWidth / window.innerHeight;
            const gameRatio = canvasWidth / canvasHeight;
            
            if (windowRatio < gameRatio) {
                // Window is narrower than game ratio
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = (window.innerWidth / gameRatio) + 'px';
            } else {
                // Window is wider than game ratio
                canvas.style.width = (window.innerHeight * gameRatio) + 'px';
                canvas.style.height = window.innerHeight + 'px';
            }
            
            // Set actual canvas dimensions for pixel-perfect rendering
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }
        
        // Resize on load and when window size changes
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Game variables
        let bird = {
            x: 80,
            y: canvasHeight / 2,
            velocity: 0,
            radius: 15
        };
        
        let pipes = [];
        let pipeWidth = 50;
        let gapHeight = 150;
        let pipeSpeed = 3;
        let pipeSpawnInterval = 100; // Frames between pipe spawns
        const pipeColor = '#33aa33';
        
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let difficulty = 1; // Starting difficulty
        
        let gravity = 0.5;
        let jumpStrength = -8;
        
        // Game functions
        function drawBird() {
            ctx.save();
            ctx.translate(bird.x, bird.y);
            
            // Rotate based on velocity
            if (gameStarted) {
                const angle = Math.min(Math.max(bird.velocity * 0.05, -0.5), 0.5);
                ctx.rotate(angle);
            }
            
            // Bird body (yellow circle)
            ctx.fillStyle = '#ffd000';
            ctx.beginPath();
            ctx.arc(0, 0, bird.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Bird beak (orange triangle)
            ctx.fillStyle = '#ff9900';
            ctx.beginPath();
            ctx.moveTo(bird.radius, 0);
            ctx.lineTo(bird.radius + 15, -8);
            ctx.lineTo(bird.radius + 15, 8);
            ctx.closePath();
            ctx.fill();
            
            // Bird eye
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(5, -5, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(6, -5, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawPipes() {
            pipes.forEach(pipe => {
                // Base pipe color
                ctx.fillStyle = pipeColor;
                
                // Color changes only after score > 10
                if (score > 10) {
                    // Darkens the pipe color based on difficulty
                    const difficultyFactor = difficulty - 1;
                    const difficultyColor = Math.max(0, 170 - difficultyFactor * 20); // Darker green
                    ctx.fillStyle = `rgb(0, ${difficultyColor}, 0)`;
                    
                    // After score 20, add red tint to show extreme difficulty
                    if (score > 20) {
                        ctx.fillStyle = `rgb(${Math.min(255, (score - 20) * 10)}, ${difficultyColor}, 0)`;
                    }
                }
                
                // Top pipe
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.gapY);
                
                // Bottom pipe
                ctx.fillRect(
                    pipe.x, 
                    pipe.gapY + gapHeight, 
                    pipeWidth, 
                    canvasHeight - (pipe.gapY + gapHeight)
                );
                
                // Add a16z logo to pipes only after score > 10
                if (score > 10) {
                    // Draw the a16z branding on pipes
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    
                    // Top pipe logo
                    if (pipe.gapY > 50) {
                        ctx.fillText('a16z', pipe.x + pipeWidth/2, pipe.gapY - 20);
                    }
                    
                    // Bottom pipe logo
                    const bottomTextY = pipe.gapY + gapHeight + 40;
                    if (bottomTextY < canvasHeight - 40) {
                        ctx.fillText('a16z', pipe.x + pipeWidth/2, bottomTextY);
                    }
                }
            });
        }
        
        function drawGround() {
            ctx.fillStyle = '#33aa33';
            ctx.fillRect(0, canvasHeight - 80, canvasWidth, 80);
        }
        
        function drawScore() {
            // Display score with different styles based on score
            ctx.textAlign = 'center';
            
            // Add shadow for visibility
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // Score <= 10 always looks the same
            if (score <= 10) {
                // Normal score
                ctx.fillStyle = 'white';
                ctx.font = '32px Arial';
                ctx.fillText(score, canvasWidth / 2, 50);
            } else if (score <= 15) {
                // Medium difficulty - brighter score
                ctx.fillStyle = '#FFDD00';
                ctx.font = 'bold 32px Arial';
                ctx.fillText(score, canvasWidth / 2, 50);
            } else {
                // High difficulty - animated score
                const pulseAmount = Math.sin(frames / 10) * 0.1 + 1;
                ctx.fillStyle = '#FF5500';
                ctx.font = 'bold 36px Arial';
                ctx.setTransform(pulseAmount, 0, 0, pulseAmount, canvasWidth / 2, 50);
                ctx.fillText(score, 0, 0);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Add warning text for extreme difficulty
                if (score > 20) {
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('EXTREME MODE', canvasWidth / 2, 75);
                }
            }
            
            // Only show difficulty level if score > 10
            if (score > 10) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.shadowBlur = 2;
                ctx.fillText('Level: ' + difficulty, canvasWidth / 2, score > 20 ? 95 : 80);
            }
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        function drawGameStartText() {
            if (!gameStarted && !gameOver) {
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Tap to Start', canvasWidth / 2, canvasHeight / 2);
            }
        }
        
        function drawGameOverText() {
            if (gameOver) {
                ctx.fillStyle = 'white';
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvasWidth / 2, canvasHeight / 2 - 70);
                
                // Draw score
                ctx.font = '24px Arial';
                ctx.fillText('Score: ' + score, canvasWidth / 2, canvasHeight / 2 - 30);
                
                // Special message for scores higher than 10
                if (score > 10) {
                    ctx.fillStyle = '#FFD700'; // Gold color
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('a16z passed this time!', canvasWidth / 2, canvasHeight / 2 + 10);
                    
                    // Add subtle glow effect
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 10;
                    ctx.fillText('a16z passed this time!', canvasWidth / 2, canvasHeight / 2 + 10);
                    ctx.shadowBlur = 0;
                }
                
                // Draw restart button
                ctx.fillStyle = '#33aa33';
                ctx.beginPath();
                ctx.arc(canvasWidth / 2, canvasHeight / 2 + 60, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw play triangle
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(canvasWidth / 2 + 10, canvasHeight / 2 + 60);
                ctx.lineTo(canvasWidth / 2 - 5, canvasHeight / 2 + 45);
                ctx.lineTo(canvasWidth / 2 - 5, canvasHeight / 2 + 75);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function updateBird() {
            if (!gameStarted || gameOver) return;
            
            bird.velocity += gravity;
            bird.y += bird.velocity;
            
            // Check ground collision
            if (bird.y + bird.radius > canvasHeight - 80) {
                bird.y = canvasHeight - 80 - bird.radius;
                endGame();
            }
            
            // Check ceiling collision
            if (bird.y - bird.radius < 0) {
                bird.y = bird.radius;
                bird.velocity = 0;
            }
        }
        
        function updatePipes() {
            if (!gameStarted || gameOver) return;
            
            // Increase difficulty based on score
            updateDifficulty();
            
            // Move pipes to the left
            pipes.forEach(pipe => {
                pipe.x -= pipeSpeed;
                
                // Check if bird passed the pipe
                if (!pipe.scored && pipe.x + pipeWidth < bird.x - bird.radius) {
                    pipe.scored = true;
                    score++;
                }
                
                // Check collision with pipe
                if (
                    bird.x + bird.radius > pipe.x && 
                    bird.x - bird.radius < pipe.x + pipeWidth
                ) {
                    // Check if bird is within the gap
                    if (
                        bird.y - bird.radius < pipe.gapY || 
                        bird.y + bird.radius > pipe.gapY + gapHeight
                    ) {
                        endGame();
                    }
                }
            });
            
            // Remove pipes that have gone off screen
            pipes = pipes.filter(pipe => pipe.x > -pipeWidth);
            
            // Add new pipe at regular intervals, adjusted by difficulty
            if (frames % pipeSpawnInterval === 0) {
                // Make the gap position more challenging based on difficulty
                const minGapY = 80 + (difficulty * 5); // Higher minimum as difficulty increases
                const maxGapY = (canvasHeight - gapHeight - 80) - (difficulty * 5); // Lower maximum
                
                pipes.push({
                    x: canvasWidth,
                    gapY: Math.floor(Math.random() * (maxGapY - minGapY)) + minGapY,
                    scored: false
                });
            }
        }
        
        // Update game difficulty based on score
        function updateDifficulty() {
            // Keep difficulty constant until score > 10
            // Then increase difficulty more rapidly
            let newDifficulty;
            
            if (score <= 10) {
                newDifficulty = 1; // Keep at level 1 for first 10 points
            } else {
                // After score > 10, increase difficulty more rapidly
                // Each point increases difficulty by 0.5 levels
                newDifficulty = Math.min(10, 1 + Math.floor((score - 10) * 0.5));
            }
            
            // Only update if difficulty has changed
            if (newDifficulty !== difficulty) {
                difficulty = newDifficulty;
                
                if (difficulty === 1) {
                    // Base difficulty settings
                    pipeSpeed = 3;
                    gapHeight = 150;
                    pipeSpawnInterval = 100;
                    gravity = 0.5;
                    jumpStrength = -8;
                } else {
                    // After 10 points, make it much harder
                    // Increase difficulty more rapidly
                    const difficultyFactor = difficulty - 1;
                    
                    // Adjust game parameters based on difficulty (more aggressive scaling)
                    pipeSpeed = 3 + (difficultyFactor * 0.8); // Pipes move faster
                    gapHeight = 150 - (difficultyFactor * 8); // Gap gets smaller faster
                    pipeSpawnInterval = 100 - (difficultyFactor * 7); // Pipes spawn more frequently
                    gravity = 0.5 + (difficultyFactor * 0.08); // Gravity increases faster
                    jumpStrength = -8 - (difficultyFactor * 0.3); // Jump strength increases to compensate
                    
                    // Ensure values stay within reasonable limits
                    gapHeight = Math.max(70, gapHeight); // Allow even smaller gaps
                    pipeSpawnInterval = Math.max(35, pipeSpawnInterval); // Allow more frequent spawns
                    
                    console.log("Difficulty increased to:", difficulty);
                }
            }
        }
        
        function endGame() {
            gameOver = true;
            
            // Send score to Telegram if running in Telegram Mini App
            if (tgApp) {
                try {
                    const data = { score: score };
                    tgApp.sendData(JSON.stringify(data));
                } catch (error) {
                    console.error("Error sending score to Telegram:", error);
                }
            }
        }
        
        function restartGame() {
            // Reset game state
            bird = {
                x: 80,
                y: canvasHeight / 2,
                velocity: 0,
                radius: 15
            };
            
            pipes = [];
            score = 0;
            gameOver = false;
            gameStarted = false;
            frames = 0;
        }
        
        // Input handling
        function handleTap(event) {
            event.preventDefault();
            
            // Prevent handling the same tap multiple times
            if (event.type === 'touchstart' && event.touches.length > 1) return;
            
            // If game over, check if tap is on restart button
            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const clickX = (event.clientX || event.touches[0].clientX) - rect.left;
                const clickY = (event.clientY || event.touches[0].clientY) - rect.top;
                
                // Scale coordinates to match canvas dimensions
                const scaleX = canvasWidth / rect.width;
                const scaleY = canvasHeight / rect.height;
                
                const scaledX = clickX * scaleX;
                const scaledY = clickY * scaleY;
                
                // Check if click is on restart button (adjusted for new position)
                const distance = Math.sqrt(
                    Math.pow(scaledX - canvasWidth / 2, 2) + 
                    Math.pow(scaledY - (canvasHeight / 2 + 60), 2)
                );
                
                if (distance <= 30) {
                    restartGame();
                }
                
                return;
            }
            
            // Start game if not started
            if (!gameStarted) {
                gameStarted = true;
                return;
            }
            
            // Jump
            bird.velocity = jumpStrength;
        }
        
        canvas.addEventListener('click', handleTap);
        canvas.addEventListener('touchstart', handleTap);
        
        // Game loop
        let frames = 0;
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Update game state
            updateBird();
            updatePipes();
            
            // Draw game elements
            drawPipes();
            drawGround();
            drawBird();
            drawScore();
            drawGameStartText();
            drawGameOverText();
            
            frames++;
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
    </script>
</body>
</html>